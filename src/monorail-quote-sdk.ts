//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://testnet-pathfinder.monorail.xyz/v4";

    }

    /**
     * Quote
     * @param source Source of the quote request, your App ID
     * @param from The token address you are swapping from (must be a valid EVM address)
     * @param to The token address you are swapping to (must be a valid EVM address)
     * @param amount The amount to trade in decimal human readable format (e.g. 1.5)
     * @param sender (optional) The address that will be executing the transaction (must be a valid EVM address if provided, if not provided no transaction will be added)
     * @param max_slippage (optional) Maximum allowed slippage in basis points (0.01%), between 1-1000. Defaults to 50 (0.5%)
     * @param deadline (optional) Transaction deadline in seconds from now, defaults to 60 (60 seconds)
     * @param destination (optional) Address to send the resulting tokens to (must be a valid EVM address if provided, if not provided the sender will be used)
     * @return Successful quote with amounts, routes and transaction data
     */
    quote(source: string, from: string, to: string, amount: string, sender: string | null | undefined, max_slippage: number | null | undefined, deadline: number | null | undefined, destination: string | null | undefined, cancelToken?: CancelToken): Promise<QuoteOutputV4> {
        let url_ = this.baseUrl + "/quote?";
        if (source === undefined || source === null)
            throw new Error("The parameter 'source' must be defined and cannot be null.");
        else
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (sender !== undefined && sender !== null)
            url_ += "sender=" + encodeURIComponent("" + sender) + "&";
        if (max_slippage !== undefined && max_slippage !== null)
            url_ += "max_slippage=" + encodeURIComponent("" + max_slippage) + "&";
        if (deadline !== undefined && deadline !== null)
            url_ += "deadline=" + encodeURIComponent("" + deadline) + "&";
        if (destination !== undefined && destination !== null)
            url_ += "destination=" + encodeURIComponent("" + destination) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuote(_response);
        });
    }

    protected processQuote(response: AxiosResponse): Promise<QuoteOutputV4> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuoteOutputV4.fromJS(resultData200);
            return Promise.resolve<QuoteOutputV4>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Invalid parameters", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Server error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuoteOutputV4>(null as any);
    }
}

/** The transaction data that can be executed to perform the trade. */
export class GeneratedTransaction implements IGeneratedTransaction {
    /** The data payload to send to the contract, encoded as a hex string */
    data?: string | undefined;
    /** The address of the contract to execute the transaction on */
    to?: string | undefined;
    /** The value to send with the transaction, in wei. This is only needed if the from token is the native token (e.g. 0x0000000000000000000000000000000000000000) */
    value?: string | undefined;

    constructor(data?: IGeneratedTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.to = _data["to"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GeneratedTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratedTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["to"] = this.to;
        data["value"] = this.value;
        return data;
    }
}

/** The transaction data that can be executed to perform the trade. */
export interface IGeneratedTransaction {
    /** The data payload to send to the contract, encoded as a hex string */
    data?: string | undefined;
    /** The address of the contract to execute the transaction on */
    to?: string | undefined;
    /** The value to send with the transaction, in wei. This is only needed if the from token is the native token (e.g. 0x0000000000000000000000000000000000000000) */
    value?: string | undefined;
}

/** The response format for errors in the API. */
export class ErrorResponse implements IErrorResponse {
    /** A detailed message of the issue encountered */
    message?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

/** The response format for errors in the API. */
export interface IErrorResponse {
    /** A detailed message of the issue encountered */
    message?: string | undefined;
}

/** The full description of fees for this quote. */
export class ProtocolFeesV4 implements IProtocolFeesV4 {
    /** The amount of the fee shared with the referrer in full EVM format without decimals */
    fee_share_amount?: string | undefined;
    /** The fee share basis points (BPS) for the quote, e.g. 5000 = 50% of the protocol fee */
    fee_share_bps?: number | undefined;
    /** The protocol amount in full EVM format without decimals */
    protocol_amount?: string | undefined;
    /** The protocol basis points (BPS) for the quote, e.g. 10 = 0.1% */
    protocol_bps?: number | undefined;

    constructor(data?: IProtocolFeesV4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fee_share_amount = _data["fee_share_amount"];
            this.fee_share_bps = _data["fee_share_bps"];
            this.protocol_amount = _data["protocol_amount"];
            this.protocol_bps = _data["protocol_bps"];
        }
    }

    static fromJS(data: any): ProtocolFeesV4 {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolFeesV4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fee_share_amount"] = this.fee_share_amount;
        data["fee_share_bps"] = this.fee_share_bps;
        data["protocol_amount"] = this.protocol_amount;
        data["protocol_bps"] = this.protocol_bps;
        return data;
    }
}

/** The full description of fees for this quote. */
export interface IProtocolFeesV4 {
    /** The amount of the fee shared with the referrer in full EVM format without decimals */
    fee_share_amount?: string | undefined;
    /** The fee share basis points (BPS) for the quote, e.g. 5000 = 50% of the protocol fee */
    fee_share_bps?: number | undefined;
    /** The protocol amount in full EVM format without decimals */
    protocol_amount?: string | undefined;
    /** The protocol basis points (BPS) for the quote, e.g. 10 = 0.1% */
    protocol_bps?: number | undefined;
}

/** The full quote response including all details, routes and transaction data. */
export class QuoteOutputV4 implements IQuoteOutputV4 {
    /** The block number at which the quote was generated */
    block?: number | undefined;
    /** The compound impact of the quote, in percentage format. A value of 40+ is considered very high and the trade should be executed with caution. */
    compound_impact?: string | undefined;
    /** The protocol fees for the quote, including protocol BPS, fee share BPS, protocol amount and fee share amount */
    fees?: ProtocolFeesV4 | undefined;
    /** The input token address you are swapping from */
    from?: string | undefined;
    /** The gas estimate for the transaction, in wei */
    gas_estimate?: number | undefined;
    /** The timestamp when the quote was generated, in Unix time format */
    generated_at?: number | undefined;
    /** The number of hops in the route */
    hops?: number | undefined;
    /** The amount you are swapping from, in full EVM format without decimals */
    input?: string | undefined;
    /** The amount you are swapping from, in decimal human readable format */
    input_formatted?: string | undefined;
    /** The minimum amount you are guaranteed to receive, in full EVM format without decimals */
    min_output?: string | undefined;
    /** The minimum amount you are guaranteed to receive, in decimal human readable format */
    min_output_formatted?: string | undefined;
    /** The optimisation level used for the quote, e.g. "price_impact", "gas" */
    optimisation?: string | undefined;
    /** The amount you are swapping to, in full EVM format without decimals */
    output?: string | undefined;
    /** The amount you are swapping to, in decimal human readable format */
    output_formatted?: string | undefined;
    /** The unique identifier for the quote */
    quote_id?: string | undefined;
    /** The source of the quote request, your App ID */
    referrer_id?: string | undefined;
    /** The routes used for the quote, each route is a slice of Route objects */
    routes?: Route[][] | undefined;
    /** The output token address you are swapping to */
    to?: string | undefined;
    /** The transaction data for executing the quote, including the contract address, data payload and value in wei. Only added if a sender is specified.
The transaction can be executed as-is to the contract provided in the transaction section.
If no sender is specified, this will be empty and the quote cannot be executed. */
    transaction?: GeneratedTransaction | undefined;

    constructor(data?: IQuoteOutputV4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.block = _data["block"];
            this.compound_impact = _data["compound_impact"];
            this.fees = _data["fees"] ? ProtocolFeesV4.fromJS(_data["fees"]) : <any>undefined;
            this.from = _data["from"];
            this.gas_estimate = _data["gas_estimate"];
            this.generated_at = _data["generated_at"];
            this.hops = _data["hops"];
            this.input = _data["input"];
            this.input_formatted = _data["input_formatted"];
            this.min_output = _data["min_output"];
            this.min_output_formatted = _data["min_output_formatted"];
            this.optimisation = _data["optimisation"];
            this.output = _data["output"];
            this.output_formatted = _data["output_formatted"];
            this.quote_id = _data["quote_id"];
            this.referrer_id = _data["referrer_id"];
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(item);
            }
            this.to = _data["to"];
            this.transaction = _data["transaction"] ? GeneratedTransaction.fromJS(_data["transaction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): QuoteOutputV4 {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteOutputV4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["block"] = this.block;
        data["compound_impact"] = this.compound_impact;
        data["fees"] = this.fees ? this.fees.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["gas_estimate"] = this.gas_estimate;
        data["generated_at"] = this.generated_at;
        data["hops"] = this.hops;
        data["input"] = this.input;
        data["input_formatted"] = this.input_formatted;
        data["min_output"] = this.min_output;
        data["min_output_formatted"] = this.min_output_formatted;
        data["optimisation"] = this.optimisation;
        data["output"] = this.output;
        data["output_formatted"] = this.output_formatted;
        data["quote_id"] = this.quote_id;
        data["referrer_id"] = this.referrer_id;
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item);
        }
        data["to"] = this.to;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        return data;
    }
}

/** The full quote response including all details, routes and transaction data. */
export interface IQuoteOutputV4 {
    /** The block number at which the quote was generated */
    block?: number | undefined;
    /** The compound impact of the quote, in percentage format. A value of 40+ is considered very high and the trade should be executed with caution. */
    compound_impact?: string | undefined;
    /** The protocol fees for the quote, including protocol BPS, fee share BPS, protocol amount and fee share amount */
    fees?: ProtocolFeesV4 | undefined;
    /** The input token address you are swapping from */
    from?: string | undefined;
    /** The gas estimate for the transaction, in wei */
    gas_estimate?: number | undefined;
    /** The timestamp when the quote was generated, in Unix time format */
    generated_at?: number | undefined;
    /** The number of hops in the route */
    hops?: number | undefined;
    /** The amount you are swapping from, in full EVM format without decimals */
    input?: string | undefined;
    /** The amount you are swapping from, in decimal human readable format */
    input_formatted?: string | undefined;
    /** The minimum amount you are guaranteed to receive, in full EVM format without decimals */
    min_output?: string | undefined;
    /** The minimum amount you are guaranteed to receive, in decimal human readable format */
    min_output_formatted?: string | undefined;
    /** The optimisation level used for the quote, e.g. "price_impact", "gas" */
    optimisation?: string | undefined;
    /** The amount you are swapping to, in full EVM format without decimals */
    output?: string | undefined;
    /** The amount you are swapping to, in decimal human readable format */
    output_formatted?: string | undefined;
    /** The unique identifier for the quote */
    quote_id?: string | undefined;
    /** The source of the quote request, your App ID */
    referrer_id?: string | undefined;
    /** The routes used for the quote, each route is a slice of Route objects */
    routes?: Route[][] | undefined;
    /** The output token address you are swapping to */
    to?: string | undefined;
    /** The transaction data for executing the quote, including the contract address, data payload and value in wei. Only added if a sender is specified.
The transaction can be executed as-is to the contract provided in the transaction section.
If no sender is specified, this will be empty and the quote cannot be executed. */
    transaction?: GeneratedTransaction | undefined;
}

/** The routing information for a trade, including the input and output tokens, price impact, and splits. This alone cannot be used to reconstruct the trade as provided in the transaction section. */
export class Route implements IRoute {
    /** The input token for this leg of the route */
    from?: string | undefined;
    /** The symbol of the input token for this leg of the route */
    from_symbol?: string | undefined;
    /** The split of the trade to different exchanges */
    splits?: Split[] | undefined;
    /** The output token for this leg of the route */
    to?: string | undefined;
    /** The symbol of the output token for this leg of the route */
    to_symbol?: string | undefined;
    /** The total price impact for this leg of the route */
    weighted_price_impact?: string | undefined;

    constructor(data?: IRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.from_symbol = _data["from_symbol"];
            if (Array.isArray(_data["splits"])) {
                this.splits = [] as any;
                for (let item of _data["splits"])
                    this.splits!.push(Split.fromJS(item));
            }
            this.to = _data["to"];
            this.to_symbol = _data["to_symbol"];
            this.weighted_price_impact = _data["weighted_price_impact"];
        }
    }

    static fromJS(data: any): Route {
        data = typeof data === 'object' ? data : {};
        let result = new Route();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["from_symbol"] = this.from_symbol;
        if (Array.isArray(this.splits)) {
            data["splits"] = [];
            for (let item of this.splits)
                data["splits"].push(item ? item.toJSON() : <any>undefined);
        }
        data["to"] = this.to;
        data["to_symbol"] = this.to_symbol;
        data["weighted_price_impact"] = this.weighted_price_impact;
        return data;
    }
}

/** The routing information for a trade, including the input and output tokens, price impact, and splits. This alone cannot be used to reconstruct the trade as provided in the transaction section. */
export interface IRoute {
    /** The input token for this leg of the route */
    from?: string | undefined;
    /** The symbol of the input token for this leg of the route */
    from_symbol?: string | undefined;
    /** The split of the trade to different exchanges */
    splits?: Split[] | undefined;
    /** The output token for this leg of the route */
    to?: string | undefined;
    /** The symbol of the output token for this leg of the route */
    to_symbol?: string | undefined;
    /** The total price impact for this leg of the route */
    weighted_price_impact?: string | undefined;
}

/** The routing information for a split */
export class Split implements ISplit {
    /** The fee charged by the protocol for this trade, in basis points (BPS) */
    fee?: string | undefined;
    /** The percentage of the total trade that this split represents, in decimal format (e.g. 0.5 for 50%) */
    percentage?: string | undefined;
    /** The price impact of this split, in percentage format */
    price_impact?: string | undefined;
    /** The protocol used for this split */
    protocol?: string | undefined;

    constructor(data?: ISplit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fee = _data["fee"];
            this.percentage = _data["percentage"];
            this.price_impact = _data["price_impact"];
            this.protocol = _data["protocol"];
        }
    }

    static fromJS(data: any): Split {
        data = typeof data === 'object' ? data : {};
        let result = new Split();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fee"] = this.fee;
        data["percentage"] = this.percentage;
        data["price_impact"] = this.price_impact;
        data["protocol"] = this.protocol;
        return data;
    }
}

/** The routing information for a split */
export interface ISplit {
    /** The fee charged by the protocol for this trade, in basis points (BPS) */
    fee?: string | undefined;
    /** The percentage of the total trade that this split represents, in decimal format (e.g. 0.5 for 50%) */
    percentage?: string | undefined;
    /** The price impact of this split, in percentage format */
    price_impact?: string | undefined;
    /** The protocol used for this split */
    protocol?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}